// GrindingComputeShader.compute
// GPU-accelerated multi-directional vertex grinding with BVH support

#pragma kernel CSMain

// Vertex data
RWStructuredBuffer<float4> vertices;
RWStructuredBuffer<float4> results;
uint vertexCount;

// Tool transform
float4x4 toolWorldToLocal;
float4x4 toolLocalToWorld;

// Grinding axis (0=X, 1=Y, 2=Z)
int grindAxisIndex;
float grindAxisSign;

// Custom direction option
int useCustomDirection;
float3 customDirection;
float3 grindDirection;

// Bounds clamping
float3 boundsMin;
float3 boundsMax;
int enforceBounds;

// BVH data
struct BVHNode
{
    float3 boundsMin;
    int leftOrTriangleOffset;
    float3 boundsMax;
    int triangleCount;
};

struct GPUTriangle
{
    float3 v0;
    float pad0;
    float3 v1;
    float pad1;
    float3 v2;
    float pad2;
};

StructuredBuffer<BVHNode> bvhNodes;
StructuredBuffer<GPUTriangle> bvhTriangles;
int bvhNodeCount;
int useBVH;

#define THREAD_GROUP_SIZE 256
#define MAX_STACK_SIZE 32
#define EPSILON 0.0001

// Helper to get component by index
float GetComponent(float3 v, int idx)
{
    if (idx == 0) return v.x;
    if (idx == 1) return v.y;
    return v.z;
}

// Helper to set component by index
float3 SetComponent(float3 v, int idx, float value)
{
    if (idx == 0) v.x = value;
    else if (idx == 1) v.y = value;
    else v.z = value;
    return v;
}

// Clamp position to AABB bounds
float3 ClampToAABB(float3 pos, float3 bmin, float3 bmax)
{
    return clamp(pos, bmin, bmax);
}

// Check if position is inside AABB
bool IsInsideAABB(float3 pos, float3 bmin, float3 bmax)
{
    return pos.x >= bmin.x && pos.x <= bmax.x &&
           pos.y >= bmin.y && pos.y <= bmax.y &&
           pos.z >= bmin.z && pos.z <= bmax.z;
}

// Ray-AABB intersection
bool RayIntersectsBounds(float3 origin, float3 invDir, float3 bmin, float3 bmax, float maxDist)
{
    float3 t1 = (bmin - origin) * invDir;
    float3 t2 = (bmax - origin) * invDir;
    
    float3 tmin3 = min(t1, t2);
    float3 tmax3 = max(t1, t2);
    
    float tmin = max(max(tmin3.x, tmin3.y), tmin3.z);
    float tmax = min(min(tmax3.x, tmax3.y), tmax3.z);
    
    return tmax >= 0 && tmin <= tmax && tmin <= maxDist;
}

// Möller–Trumbore ray-triangle intersection
bool RayTriangleIntersection(float3 origin, float3 dir, float3 v0, float3 v1, float3 v2, out float t)
{
    t = 0;
    
    float3 edge1 = v1 - v0;
    float3 edge2 = v2 - v0;
    float3 h = cross(dir, edge2);
    float a = dot(edge1, h);
    
    if (abs(a) < EPSILON)
        return false;
    
    float f = 1.0 / a;
    float3 s = origin - v0;
    float u = f * dot(s, h);
    
    if (u < 0.0 || u > 1.0)
        return false;
    
    float3 q = cross(s, edge1);
    float v = f * dot(dir, q);
    
    if (v < 0.0 || u + v > 1.0)
        return false;
    
    t = f * dot(edge2, q);
    return t > EPSILON;
}

// BVH raycast - returns true if hit, with hit point and distance
bool BVHRaycast(float3 origin, float3 direction, out float3 hitPoint, out float hitDistance)
{
    hitPoint = float3(0, 0, 0);
    hitDistance = 1e10;
    bool anyHit = false;
    
    if (bvhNodeCount == 0)
        return false;
    
    float3 invDir = float3(
        abs(direction.x) > EPSILON ? 1.0 / direction.x : (direction.x >= 0 ? 1e10 : -1e10),
        abs(direction.y) > EPSILON ? 1.0 / direction.y : (direction.y >= 0 ? 1e10 : -1e10),
        abs(direction.z) > EPSILON ? 1.0 / direction.z : (direction.z >= 0 ? 1e10 : -1e10)
    );
    
    int stack[MAX_STACK_SIZE];
    int stackPtr = 0;
    stack[stackPtr++] = 0;
    
    while (stackPtr > 0)
    {
        int nodeIdx = stack[--stackPtr];
        
        if (nodeIdx < 0 || nodeIdx >= bvhNodeCount)
            continue;
            
        BVHNode node = bvhNodes[nodeIdx];
        
        if (!RayIntersectsBounds(origin, invDir, node.boundsMin, node.boundsMax, hitDistance))
            continue;
        
        if (node.triangleCount > 0)
        {
            for (int i = 0; i < node.triangleCount; i++)
            {
                GPUTriangle tri = bvhTriangles[node.leftOrTriangleOffset + i];
                float t;
                if (RayTriangleIntersection(origin, direction, tri.v0, tri.v1, tri.v2, t))
                {
                    if (t < hitDistance)
                    {
                        hitDistance = t;
                        hitPoint = origin + direction * t;
                        anyHit = true;
                    }
                }
            }
        }
        else
        {
            if (stackPtr < MAX_STACK_SIZE - 2)
            {
                int leftChild = node.leftOrTriangleOffset;
                int rightChild = leftChild + 1;
                
                if (rightChild < bvhNodeCount)
                    stack[stackPtr++] = rightChild;
                if (leftChild < bvhNodeCount)
                    stack[stackPtr++] = leftChild;
            }
        }
    }
    
    return anyHit;
}

// Closest point on a triangle to a given point
float3 ClosestPointOnTriangle(float3 p, float3 a, float3 b, float3 c)
{
    float3 ab = b - a;
    float3 ac = c - a;
    float3 ap = p - a;
    
    float d1 = dot(ab, ap);
    float d2 = dot(ac, ap);
    if (d1 <= 0.0 && d2 <= 0.0)
        return a;
    
    float3 bp = p - b;
    float d3 = dot(ab, bp);
    float d4 = dot(ac, bp);
    if (d3 >= 0.0 && d4 <= d3)
        return b;
    
    float vc = d1 * d4 - d3 * d2;
    if (vc <= 0.0 && d1 >= 0.0 && d3 <= 0.0)
    {
        float v = d1 / (d1 - d3);
        return a + v * ab;
    }
    
    float3 cp = p - c;
    float d5 = dot(ab, cp);
    float d6 = dot(ac, cp);
    if (d6 >= 0.0 && d5 <= d6)
        return c;
    
    float vb = d5 * d2 - d1 * d6;
    if (vb <= 0.0 && d2 >= 0.0 && d6 <= 0.0)
    {
        float w = d2 / (d2 - d6);
        return a + w * ac;
    }
    
    float va = d3 * d6 - d5 * d4;
    if (va <= 0.0 && (d4 - d3) >= 0.0 && (d5 - d6) >= 0.0)
    {
        float w = (d4 - d3) / ((d4 - d3) + (d5 - d6));
        return b + w * (c - b);
    }
    
    float denom = 1.0 / (va + vb + vc);
    float v2 = vb * denom;
    float w2 = vc * denom;
    return a + ab * v2 + ac * w2;
}

// Distance from point to AABB (0 if inside)
float DistanceToAABB(float3 point, float3 bmin, float3 bmax)
{
    float3 closest = clamp(point, bmin, bmax);
    return length(point - closest);
}

// Find closest point on mesh using BVH
float3 ClosestPointOnMesh(float3 point, out float closestDistance)
{
    closestDistance = 1e10;
    float3 closestPoint = point;
    
    if (bvhNodeCount == 0)
        return point;
    
    int stack[MAX_STACK_SIZE];
    int stackPtr = 0;
    stack[stackPtr++] = 0;
    
    while (stackPtr > 0)
    {
        int nodeIdx = stack[--stackPtr];
        
        if (nodeIdx < 0 || nodeIdx >= bvhNodeCount)
            continue;
        
        BVHNode node = bvhNodes[nodeIdx];
        
        // Check if this node could contain a closer point
        float boundsDist = DistanceToAABB(point, node.boundsMin, node.boundsMax);
        if (boundsDist >= closestDistance)
            continue;
        
        if (node.triangleCount > 0)
        {
            // Leaf node - check triangles
            for (int i = 0; i < node.triangleCount; i++)
            {
                GPUTriangle tri = bvhTriangles[node.leftOrTriangleOffset + i];
                float3 triClosest = ClosestPointOnTriangle(point, tri.v0, tri.v1, tri.v2);
                float dist = length(point - triClosest);
                if (dist < closestDistance)
                {
                    closestDistance = dist;
                    closestPoint = triClosest;
                }
            }
        }
        else
        {
            // Internal node - add children to stack
            if (stackPtr < MAX_STACK_SIZE - 2)
            {
                int leftChild = node.leftOrTriangleOffset;
                int rightChild = leftChild + 1;
                
                // Add both children (could optimize by checking closer first)
                if (rightChild < bvhNodeCount)
                    stack[stackPtr++] = rightChild;
                if (leftChild < bvhNodeCount)
                    stack[stackPtr++] = leftChild;
            }
        }
    }
    
    return closestPoint;
}

// Check if in cross-section perpendicular to grind axis
bool IsInCrossSection(float3 localPos, float3 halfExtents, int axisIndex)
{
    if (axisIndex == 0)
    {
        return abs(localPos.y) <= halfExtents.y && abs(localPos.z) <= halfExtents.z;
    }
    else if (axisIndex == 1)
    {
        return abs(localPos.x) <= halfExtents.x && abs(localPos.z) <= halfExtents.z;
    }
    else
    {
        return abs(localPos.x) <= halfExtents.x && abs(localPos.y) <= halfExtents.y;
    }
}

// Check if point should be ground and get target position
bool ShouldGrindAndGetTarget(float3 localPos, float3 halfExtents, int axisIndex, float axisSign, out float3 targetLocal)
{
    targetLocal = localPos;
    
    float grindSurfaceLocal = axisSign * GetComponent(halfExtents, axisIndex);
    float pointOnAxis = GetComponent(localPos, axisIndex);
    
    bool shouldGrind;
    if (axisSign > 0)
    {
        shouldGrind = pointOnAxis < grindSurfaceLocal;
    }
    else
    {
        shouldGrind = pointOnAxis > grindSurfaceLocal;
    }
    
    if (shouldGrind)
    {
        targetLocal = SetComponent(localPos, axisIndex, grindSurfaceLocal);
    }
    
    return shouldGrind;
}

// Main clamping function - multi-tier approach
float3 ClampToMeshSurface(float3 originalPos, float3 targetPos, float3 direction)
{
    // Step 1: Always clamp to AABB first - this is the absolute boundary
    float3 clampedPos = ClampToAABB(targetPos, boundsMin, boundsMax);
    
    // If BVH is not available, return AABB-clamped position
    if (useBVH == 0 || bvhNodeCount == 0)
    {
        return clampedPos;
    }
    
    // Step 2: Try raycast for precise surface clamping
    float3 hitPoint;
    float hitDistance;
    
    if (BVHRaycast(originalPos, direction, hitPoint, hitDistance))
    {
        // Calculate how far we're trying to move in the grind direction
        float3 moveVector = targetPos - originalPos;
        float moveDistanceAlongGrind = dot(moveVector, direction);
        
        // If we're trying to move past the surface, clamp to surface
        if (moveDistanceAlongGrind > 0 && moveDistanceAlongGrind > hitDistance)
        {
            clampedPos = hitPoint;
        }
        // else: Movement is within bounds, use the AABB-clamped position
    }
    else
    {
        // Step 3: Raycast missed - use closest point on mesh as fallback
        // Only if the AABB-clamped position is different from target
        float distFromTarget = length(clampedPos - targetPos);
        if (distFromTarget > EPSILON)
        {
            float closestDist;
            float3 closestPoint = ClosestPointOnMesh(clampedPos, closestDist);
            
            // Use the closest point, but ensure it's still within AABB
            clampedPos = ClampToAABB(closestPoint, boundsMin, boundsMax);
        }
    }
    
    // Final safety check: ensure we never return a position outside AABB
    return ClampToAABB(clampedPos, boundsMin, boundsMax);
}

[numthreads(THREAD_GROUP_SIZE, 1, 1)]
void CSMain(uint3 id : SV_DispatchThreadID)
{
    uint index = id.x;
    
    if (index >= vertexCount)
    {
        return;
    }
    
    float4 vertex = vertices[index];
    float3 worldPos = vertex.xyz;
    float3 originalWorldPos = worldPos;
    float affected = 0.0;
    
    // Transform to tool local space
    float3 localPos = mul(toolWorldToLocal, float4(worldPos, 1.0)).xyz;
    float3 halfExtents = float3(0.5, 0.5, 0.5);
    
    // Check if in tool's cross-section
    if (IsInCrossSection(localPos, halfExtents, grindAxisIndex))
    {
        float3 targetLocal;
        if (ShouldGrindAndGetTarget(localPos, halfExtents, grindAxisIndex, grindAxisSign, targetLocal))
        {
            // Transform back to world space
            float3 targetPos = mul(toolLocalToWorld, float4(targetLocal, 1.0)).xyz;
            
            // Apply bounds clamping with multi-tier approach
            if (enforceBounds > 0)
            {
                float3 direction = useCustomDirection > 0 ? normalize(customDirection) : normalize(grindDirection);
                targetPos = ClampToMeshSurface(originalWorldPos, targetPos, direction);
            }
            
            worldPos = targetPos;
            affected = 1.0;
        }
    }
    
    results[index] = float4(worldPos, affected);
}